#lang racket

(define tile-names '#(space   wall goal box box/goal player player/goal))
(define tile-chars '#(#\space #\.  #\*  #\O #\@      #\t    #\%))
(match-define (list tile:space tile:wall tile:goal tile:box tile:box/goal
                    tile:player tile:player/goal)
              (range (vector-length tile-names)))

(struct player (position moves))
(struct state (player board))

(define (board^ b x y)
  (if (< -1 y (vector-length b))
    (let ((row (vector-ref b y)))
      (if (< -1 x (vector-length row))
        (vector-ref row x)
        tile:wall))
    tile:wall))
(define (board^! b x y t)
  (define row (vector-copy (vector-ref b y)))
  (vector-set! b y row)
  (vector-set! row x t))

(define (state->string st)
  (match-define (cons p:x p:y) (player-position (state-player st)))
  (define board:current (state-board st))
  (define board-chars
    (vector-map (lambda (row)
                  (vector-map (lambda (tile) (vector-ref tile-chars tile))
                              row))
                board:current))
  (define player-tile (board^ board:current p:x p:y))
  (define (? tile) (equal? tile player-tile))
  (define player-char
    (vector-ref tile-chars
                (cond ((? tile:goal ) tile:player/goal)
                      ((? tile:space) tile:player)
                      (else (error "player on invalid tile:" player-tile)))))
  (board^! board-chars p:x p:y player-char)
  (string-append*
    (for/list ((row board-chars))
              (string-append (list->string (vector->list row)) "\n"))))

(define (state-won? st)
  (define goal-count 0)
  (for ((row (state-board st)))
       (for ((tile row))
            (when (equal? tile:goal tile) (set! goal-count (+ 1 goal-count)))))
  (= 0 goal-count))

(define (state-move st v:x v:y)
  (define board:current (state-board st))
  (match-define (cons p:x p:y) (player-position (state-player st)))
  (define t1:x (+ p:x  v:x))
  (define t1:y (+ p:y  v:y))
  (define t2:x (+ t1:x v:x))
  (define t2:y (+ t1:y v:y))
  (define target1 (board^ board:current t1:x t1:y))
  (define target2 (board^ board:current t2:x t2:y))
  (define board:next (vector-copy board:current))
  (define (board^!! t^ tt^)
    (board^! board:next t1:x t1:y t^)
    (board^! board:next t2:x t2:y tt^))
  (define (t12? t1 t2) (and (equal? target1 t1) (equal? target2 t2)))
  (cond ((or (equal? target1 tile:space) (equal? target1 tile:goal)) #t)
        ((t12? tile:box      tile:space) (board^!! tile:space tile:box))
        ((t12? tile:box      tile:goal ) (board^!! tile:space tile:box/goal))
        ((t12? tile:box/goal tile:space) (board^!! tile:goal  tile:box))
        ((t12? tile:box/goal tile:goal ) (board^!! tile:goal  tile:box/goal))
        (else (set! board:next #f)))
  (if board:next
    (state (player (cons t1:x t1:y) (+ 1 (player-moves (state-player st))))
           board:next)
    st))

(define (play st)
  (for ((name tile-names) (ch tile-chars))
       (display (string ch)) (display " = ") (displayln name))
  (displayln (state->string st))
  (display "Move (up=w left=a down=s right=d): ")
  (define input (read))
  (when (eof-object? input) (displayln "\nThanks for playing!"))
  (unless (eof-object? input)
    (define next (case input
                   ((w) (state-move st  0 -1))
                   ((a) (state-move st -1  0))
                   ((s) (state-move st  0  1))
                   ((d) (state-move st  1  0))
                   (else (displayln "Invalid move!") st)))
    (if (state-won? next)
      (begin (displayln (state->string next))
             (display "You won in ")
             (display (player-moves (state-player next)))
             (displayln " moves!"))
      (play next))))

(define level1
  (state (player (cons 2 2) 0)
    '#(#(0 0 1 1 1 1 1 0)
       #(1 1 1 0 0 0 1 0)
       #(1 2 0 3 0 0 1 0)
       #(1 1 1 0 3 2 1 0)
       #(1 2 1 1 3 0 1 0)
       #(1 0 1 0 2 0 1 1)
       #(1 3 0 4 3 3 2 1)
       #(1 0 0 0 2 0 0 1)
       #(1 1 1 1 1 1 1 1))))

(play level1)
